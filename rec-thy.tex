%
%  untitled
%
%  Created by Peter M. Gerdes on 2010-10-14.
%  Copyright (c) 2010 . All rights reserved.
%

\documentclass[11pt,oneside]{article}
\usepackage{amsfonts}
\usepackage{rec-thy}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{xtab}


\newcommand{\tab}{\hspace{1cm}}
% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}
%\usepackage[parfill]{parskip}
%\usepackage{setspace}

% Multipart figures
%\usepackage{subfigure}


% Surround parts of graphics with box
%\usepackage{boxedminipage}

% Package for including code in the document
%\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
%\usepackage{minitoc}


%\usepackage[pdftex]{graphicx}
%\DeclareGraphicsExtensions{.pdf, .jpg, .tif}

\title{The rec-thy Package}
\author{Peter M. Gerdes (gerdes@invariant.org)}
\date{2011-01-01: Version 1.2}

\begin{document}




\maketitle


\begin{abstract}
	The rec-thy package is designed to help mathematicians publishing papers in the area of recursion theory (aka Computability Theory) easily use standard notation.  This includes easy commands to denote Turing reductions, Turing functionals, \ce sets, stagewise computations, forcing and syntactic classes.
\end{abstract}

\section{Introduction}
This package aims to provide a useful set of \LaTeX { }macros covering basic computability theory notation.  Given the variation in usage in several areas this package had to pick particular notational conventions.  The package author would like to encourage uniformity in these conventions but has included a multitude of package options to allow individual authors to choose alternative conventions or exclude that part of the package.  Some effort has been made to align the semantic content of documents created with this package with the \LaTeX { }source.  The author hopes that eventually this package may be incorporated into some larger package for typesetting papers in mathematical logic.

While computability theory is now the more popular name for the subject also known as recursion theory the author deliberately choose to title this package rec-thy to avoid confusion with the proliferation of packages for typesetting computer science related disciplines.  While the subject matter of computability theory and theoretical computer science overlap significantly the notational conventions often differ.

Comments, patches, suggestions etc.. are all welcome.

\section{Usage}
Include the package in your document by placing \verb=\usepackage{rec-thy}= into your preamble after placing rec-thy.sty somewhere \TeX{ } can find it.  The commands in this package have been divided into related groups.  The commands in a given section can be disabled by passing the appropriate package option.  For instance to disable the commands in the general mathematics section and the delimiters section you would include the following in your preamble \verb=\usepackage[nomath,nodelim]{rec-thy}=.  The commands in each subsection along with their results are listed below and the options to disable the commands in each grouping or modify their behavior are listed in that subsection.  Aliases and variants of a command are listed below the initial version of a command and aliases are indented.

Significant use is made in this package of optional arguments delimited either by square brackets or parenthesis.  Users of the package should take care to wrap arguments that may themselves include brackets or parenthesis in braces.  For example \verb=\REset(\REset(X){e}){i}= should be fixed to \verb=\REset({\REset(X){e}}){i}=.   

\section{Commands}
A few general conventions are usually followed in the commands.  Whenever an operator can be used as a binary operator (as in \( X \union Y \)) and as an operation on some collection \( \Union_{i \in \omega} X_i \) the binary operator will begin with a lowercase letter \verb=\union= and the operation on the collection will begin with a capital letter \verb=\Union=.  If the first letter is already capitalized then the second letter is used instead.

Objects that have a natural stagewise approximation generally admit an optional argument in brackets to specify a stage.  For instance \( \verb=\REset[s]{e}= \) yields \( \REset[s]{e} \).  An optional argument in parenthesis is used for relativization.  For instance \( \verb=\REset(X){e}= \) produces \( \REset(X){e} \).  A notable exception to this rule are the formula classes where square brackets are used to indicate an oracle to be placed in the superscript, e.g.,  \( \verb=\pizn[X]{2}= \) yields \( \pizn[X]{2} \), so as not to generate confusion with the alternative notion \( \pizn{2}(X) \).  Also a lowercase first letter in a formula class indicates the lightface version while a capital first letter indicates the boldface version.

Unless indicated otherwise all macros are to be used inside math mode.  Indented commands indicate an alias for the command on the line above
\subsection{Computations}
To disable these commands pass the option \verb=nocomputations=. \\

\begin{xtabular}{l |  l | l}\toprule 
	\verb=\murec{x}{f(x)>1}=					& \( 	\murec{x}{f(x)>1}                     \)	& Least \( x \) satisfying condition. \\ \midrule
	\verb=\recfnl{e}{Y}{x}=                                	& \( 	\recfnl{e}{Y}{x}                      	   \)   &\multirow{4}{*}{Computable functions/functionals} \\[6pt]
	\verb=\recfnl[s]{e}{Y}{x}=                             & \( 	\recfnl[s]{e}{Y}{x}                   	   \)   & \\[6pt]
	\verb=\recfnl{e}{Y}{}=                                 & \( 	\recfnl{e}{Y}{}                       	   \)   & \\[6pt]
	\verb=\recfnl{e}{}{x}=                                 & \( 	\recfnl{e}{}{x}                       	   \)   & \\[6pt]
	\verb=\recfnl{e}{}{}=                                  & \( 	\recfnl{e}{}{}                        	   \)   & \\ \midrule
	\verb=\recfnl{e}{}{} \cequiv \recfnl{i}{}{}=           & \( 	\recfnl{e}{}{} \cequiv \recfnl{i}{}{} 	   \)   & Equivalent computations\\ \midrule
	\verb=\recfnl{e}{}{} \ncequiv \recfnl{i}{}{}=          & \( 	\recfnl{e}{}{} \ncequiv \recfnl{i}{}{}	   \)   & Inequivalent computations\\ \midrule
	\verb=\recfnl{e}{}{x}\conv=                            & \( 	\recfnl{e}{}{x}\conv                  	   \)   &\multirow{2}{*}{Convergence} \\[6pt]
	\tab \verb=\recfnl{e}{}{x}\conv[s]=                         & \( 	\recfnl{e}{}{x}\conv[s]               	   \)   & \\ \midrule
	\verb=\recfnl{e}{}{x}\nconv=                           & \( 	\recfnl{e}{}{x}\nconv                 	   \)   &\multirow{2}{*}{Divergence} \\[6pt]
	\tab \verb=\recfnl{e}{}{x}\nconv[s]=                        & \( 	\recfnl{e}{}{x}\nconv[s]              	   \)   & \\ \midrule
	\verb=\use{\recfnl{e}{Y}{x}}=                          & \( 	\use{\recfnl{e}{Y}{x}}                	   \)   & Use of a computation. \\ \midrule
	\verb=\REset{e}=                                       & \( 	\REset{e}                             	   \)   & \multirow{4}{*}{c.e. sets} \\[6pt] 
	 \verb=\REset[s]{e}=                                    & \( 	\REset[s]{e}                          	   \)   & \\[6pt] 
	 \verb=\REset(X){e}=                                    & \( 	\REset(X){e}                          	   \)   & \\[6pt] 
	 \verb=\REset[s](X){e}=                                 & \( 	\REset[s](X){e}                       	   \)   & \\ \midrule
	\verb=\iREAop{e}(\eset)=                               & \multirow{2}{*}{\( 	\iREAop{e}(\eset)                     	   \)}   &\multirow{2}{*}{1-REA operator} \\ 
	\tab \verb=\reaop*{e}(\eset)=                               &    & \\ \midrule
	\verb=\alphaREAop{\alpha}(\eset)=                      & \multirow{2}{*}{\( 	\alphaREAop{\alpha}(\eset)            	   \)}   &\multirow{2}{*}{\( \alpha \)-REA operator} \\[6pt]
	\tab \verb=\reaop{\alpha}(\eset)=                           &    & \\[6pt]
	\verb=\alphaREAop[f]{\alpha}(\eset)=                   & \multirow{2}{*}{\( 	\alphaREAop[f]{\alpha}(\eset)         	   \)}   & \multirow{2}{*}{with particular witness to uniformity}\\[6pt]
	\tab \verb=\reaop[f]{\alpha}(\eset)=                        &  & \\ 
		\bottomrule
	\end{xtabular}          \\

\subsection{Degrees}
To disable these commands pass the option \verb=nodegrees=. \\


\begin{xtabular}{l |  l | l}\toprule 
	\verb=\Tdeg{d}=                                        & \( 	\Tdeg{d}                              	   \)   & Turing degree \\ \midrule
	\verb=\Tjump{X}=                                       & \multirow{2}{*}{\( 	\Tjump{X}                             	   \)}   & \multirow{2}{*}{Turing jump} \\
	\tab \verb=\jump{X}=                                        &  & \\ \midrule
	\verb=\jjump{X}=                                       & \( 	\jjump{X}                             	   \)   & \\ \midrule
	\verb=\jumpn{X}{n}=                                    & \( 	\jumpn{X}{n}                          	   \)   & \\ \midrule
	\verb=\Tzero=                                          & \( 	\Tzero                                	   \)   & Computable degree \\ \midrule
	\verb=\zeroj=                                          & \( 	\zeroj                                	   \)   & \\ \midrule
	\verb=\zerojj=                                         & \( 	\zerojj                               	   \)   & \\ \midrule
	\verb=\zerojjj=                                        & \( 	\zerojjj                              	   \)   & \\ \midrule
	\verb=\zeron{n}=                                       & \( 	\zeron{n}                             	   \)   & \\ \midrule
	\verb=X \Tequiv Y=                                     & \multirow{2}{*}{\( 	X \Tequiv Y                           	   \)}   & \multirow{2}{*}{Turing equivalence}\\ 
	\tab \verb=X \Teq Y=                                        &   & \\ \midrule
	\verb=X \nTequiv Y=                                    & \multirow{2}{*}{\( 	X \nTequiv Y                          	   \)}   & \multirow{2}{*}{Turing inequivalence} \\ 
	\tab \verb=X \nTeq Y=                                       &    & \\ \midrule
        \verb=X \Tlneq Y=                                      & \(  X \Tlneq Y                              	   \)   & \\ \midrule
        \verb=X \Tleq  Y=                                      & \(  X \Tleq  Y                              	   \)   & \\ \midrule
        \verb=X \Tgneq Y=                                      & \(  X \Tgneq Y                              	   \)   & \\ \midrule
        \verb=X \Tgeq  Y=                                      & \(  X \Tgeq  Y                              	   \)   & \\ \midrule
        \verb=X \Tgtr  Y=                                      & \(  X \Tgtr  Y                              	   \)   & \\ \midrule
        \verb=X \Tless Y=                                      & \(  X \Tless Y                              	   \)   & \\ \midrule
        \verb=X \nTleq Y=                                      & \(  X \nTleq Y                              	   \)   & \\ \midrule
        \verb=X \nTgeq Y=                                      & \(  X \nTgeq Y                              	   \)   & \\ \midrule
	\verb=\Tdeg{d} \Tdegjoin \Tdeg{d'}=                    & \( 	\Tdeg{d} \Tdegjoin \Tdeg{d'}          	   \)   & Join of degrees\\ \midrule
	\verb=\Tdeg{d} \Tdegmeet \Tdeg{d'}=                    & \multirow{2}{*}{\( 	\Tdeg{d} \Tdegmeet \Tdeg{d'}          	   \)}   & \multirow{2}{*}{Meet of degrees (when defined)} \\ 
	\tab \verb=\Tdeg{d} \Tmeet \Tdeg{d'}=                       &    & \\ \midrule
	\verb=X \Tplus Y=                                      & \multirow{2}{*}{\( 	X \Tplus Y                            	   \)}   & \multirow{4}{*}{Effective join of sets} \\ 
	\tab \verb=X \Tjoin Y=                                      &  & \\ 
	\verb=\TPlus_{i \in \omega} X_i=                       & \multirow{2}{*}{\( 	\TPlus_{i \in \omega} X_i            \)}   & \\ 
	\tab \verb=\TJoin_{i \in \omega} X_i=                       &    & \\ \midrule
	% \verb=\ttSYM=                                          & \( 	\ttSYM                                	   \)   & \\ \midrule
	\verb=X \ttlneq Y=                                     & \( 	X \ttlneq Y                           	   \)   & Truth table reducibilities\\ \midrule
	\verb=X \ttleq  Y=                                     & \( 	X \ttleq  Y                           	   \)   & \\ \midrule
	\verb=X \ttgneq Y=                                     & \( 	X \ttgneq Y                           	   \)   & \\ \midrule
	\verb=X \ttgeq  Y=                                     & \( 	X \ttgeq  Y                           	   \)   & \\ \midrule
	\verb=X \ttgtr  Y=                                     & \( 	X \ttgtr  Y                           	   \)   & \\ \midrule
	\verb=X \ttless Y=                                     & \( 	X \ttless Y                           	   \)   & \\ \midrule
	\verb=X \ttTleq Y=                                     & \( 	X \ttTleq Y                           	   \)   & \\ \midrule
        \verb=X \ttTgeq Y=                                     & \(  X \ttTgeq Y                             	   \)   & \\ 
		\bottomrule
	\end{xtabular}          \\


\subsection{General Math Commands}
To disable these commands pass the option \verb=nomath=. \\

\begin{tabular}{l |  l | l}\toprule                                
	\verb=\eqdef= 					& \( \eqdef \) & Definitional equals\\ \midrule
	\verb=\iffdef= 					& \( \iffdef \) & Definitional equivalence\\	\midrule
	\verb=\aut= 					& \( \aut \)  & Automorphisms of some structure\\ \midrule
	\verb=\Ord= 					& \( \Ord \) & Set of ordinals\\\midrule
	\verb=x \meet y= 				& \( x \meet y \) & \multirow{2}{*}{Meet operation} \\[6pt]
	\verb=\Meet_{i\in \omega} x_i=		& \( \Meet_{i\in \omega} x_i \) & \\ \midrule
	\verb=x \join y= 				& \(x  \join y \) & \multirow{2}{*}{Join operation}  \\[6pt] 
	\verb=\Join_{i\in \omega} x_i=		& \( \Join_{i\in \omega} x_i \) & \\ \midrule
	\verb=\abs{x}= 					& \( \abs{x} \) & Absolute value\\ \midrule
	\verb=\dom= 					& \( \dom \) & Domain \\ \midrule
	\verb=\rng= 					& \( \rng \) & Range\\ \midrule
	\verb=f\restr{X}= 				& \( f\restr{X} \) & Restriction\\ \midrule
	\verb=\ordpair{x}{y}= 				& \( \ordpair{x}{y} \)& Ordered Pair\\ \midrule
	\verb=f\map{X}{Y}= 				& \( f\map{X}{Y} \) & \multirow{2}{*}{Function specification} \\ 
	\verb=\functo{f}{X}{Y}= 			& \( \functo{f}{X}{Y} \) &\\ \midrule
	\verb=f \compfunc g=		       		& \multirow{3}{*}{\( f \compose g \)} & \multirow{3}{*}{Function composition}\\
	\tab \verb=f \funcomp g=	            		& &\\
	\tab \verb=f \compose g=	            		& &\\ \midrule
	\verb=\( \ensuretext{blah} \)=	           	& \multirow{2}{*}{\( \ensuretext{blah} \)}& \multirow{2}{*}{Types argument in text mode} \\
	\tab \verb=\ensuretext{blah}=			& & \\
	\bottomrule
\end{tabular}          \\
\newpage
\subsection{Set Notation}      
To disable these commands pass the option \verb=nosets=.\\

\begin{tabular}{l |  l | l}\toprule
	\verb=\set{(x,y)}{x > y}=	  &    \(   \set{(x,y)}{x > y} \)    & \multirow{2}{*}{Set notation}  \\[6pt] 
	\verb=\set{(x,y)}}{}=		  &    \(   \set{(x,y)}{}      \)    &  \\ \midrule
	\verb=\card{X}=                          &    \(   \card{X}                   \)    & Cardinality \\ \midrule
	\verb=X \union Y=                        &    \(   X \union Y                 \)    & \multirow{2}{*}{Union}  \\[6pt] 
	\verb=\Union_{i \in \omega} X_i=         &    \(   \Union_{i \in \omega} X_i  \)    &  \\ \midrule
	\verb=X \isect Y=                        &    \(   X \isect Y                 \)    & \multirow{2}{*}{Intersection} \\[6pt] 
	\verb=\Isect_{i \in \omega} X_i=         &    \(   \Isect_{i \in \omega} X_i  \)    &  \\ \midrule
	\verb=X \cross Y=                        &    \(   X \cross Y                 \)    & \multirow{2}{*}{Cartesian product (Cross Product)} \\[6pt] 
	\verb=\Cross_{i \in \omega} X_i=         &    \(   \Cross_{i \in \omega} X_i  \)    &  \\ \midrule
	\verb=\powset{\omega}=                   &    \(   \powset{\omega}            \)    &  Powerset \\ \midrule
	\verb=\eset=                             &    \(   \eset                      \)    &  Emptyset abbreviation\\ \midrule
	\verb=x \nin A=                          &    \(   x \nin A                   \)    &  not an element\\ \midrule
	\verb=\setcmp{X}=                        &    \(   \setcmp{X}                 \)    &  Set compliment\\[6pt] 
						 &	\( \setminuscmp{X} \)		    & With option \verb=minussetcmp= \\ \midrule
	\verb=X \setminus Y=                     &    \(   X \setminus Y              \)    & Set difference \\ \midrule
	\verb=X \symdiff Y=                      &    \(   X \symdiff Y               \)    & Symmetric difference \\ \midrule
	\verb=\interior X=                       &    \(   \interior X                \)    & Interior \\ \midrule
	\verb=\closure X=                        &    \(   \closure X                 \)    & Closure \\ \midrule
		\bottomrule
	\end{tabular}          \\
	
\subsection{Delimiters}      
To disable these commands pass the option \verb=nodelim=. \\

\begin{tabular}{l |  l | l}\toprule                                
	\verb=\gcode{\phi}= 				& \multirow{3}{*}{\( \gcode{\phi} \)} & \multirow{3}{*}{Godel Code/Corner Quotes}\\ 
	\tab \verb=\godelnum{\phi}=			& &\\
	\tab \verb=\cornerquote{\phi}=			& &\\ \midrule
	\verb=\llangle x,y,z \rrangle=			& \( \llangle x,y,z \rrangle \) & Properly spaced double angle brackets\\
	\bottomrule
\end{tabular}  

\subsection{Recursive vs. Computable}      
To disable these commands pass the option \verb=nonames=. To use recursive, r.e. and recursively enumerable everywhere pass the option \verb=re=.  To use computable, c.e. and computably enumerable everywhere pass the option \verb=ce=.  To force REA and CEA use the options \verb=rea= and \verb=cea=. If none of these options are passed the macros will expand as below.  All macros in this section work in both text and math modes.\\

\begin{tabular}{l |  l }\toprule  
\verb=\re=				 & \re			       \\ \midrule 
\verb=\ce=                               & \ce                         \\ \midrule
\verb=\REA=                              & \REA                        \\ \midrule
\verb=\CEA=                              & \CEA                        \\ \midrule
\verb=\recursive=                        & \recursive                  \\ \midrule
\verb=\computable=                       & \computable                 \\ \midrule
\verb=\recursivelyEnumerable=            & \recursivelyEnumerable      \\ \midrule             
\verb=\computablyEnumerable=             & \computablyEnumerable       \\ \midrule
\verb=\Recursive=                        & \Recursive                  \\ \midrule
\verb=\Computable=                       & \Computable                 \\ \midrule
\verb=\RecursivelyEnumerable=            & \RecursivelyEnumerable      \\ \midrule
\verb=\ComputablyEnumerable=             & \ComputablyEnumerable       \\ \midrule
	\bottomrule
\end{tabular}

\subsection{Quantifiers \& Connectives}      
To disable these commands pass the option \verb=noquants=. The commands \verb=\exists= and \verb=\forall= are standard but the package extends them.\\

\begin{tabular}{l |  l | l}\toprule                                
	\verb=\exists[x < y]=		& \( \exists[x < y ] \) & \\[6pt]
	\verb=\exists(x < y)=		& \( \exists(x < y ) \) & \\ \midrule
	\verb=\exists*=		& \multirow{2}{*}{\( \exists* \)} & \\[6pt]
	\tab \verb=\existsinf=	&				  & \\[6pt]
	\verb=\exists*[x < y]=		& \( \exists*[x < y ] \) & \\[6pt]
	\verb=\exists*(x < y)=		& \( \exists*(x < y ) \) & \\ \midrule
	\verb=\nexists[x < y]=		& \( \nexists[x < y ] \) & \\[6pt]
	\verb=\nexists(x < y)=		& \( \nexists(x < y ) \) & \\ \midrule
	\verb=\nexists*=		& \multirow{2}{*}{\( \nexists* \)} & \\[6pt]
	\tab \verb=\nexistsinf=	&				  & \\[6pt]
	\verb=\nexists*[x < y]=		& \( \nexists*[x < y ] \) & \\[6pt]
	\verb=\nexists*(x < y)=		& \( \nexists*(x < y ) \) & \\ \midrule
	\verb=\forall[x < y]=		& \( \forall[x < y ] \) & \\[6pt]
	\tab \verb=\forall(x < y)=		& \( \forall(x < y ) \) & \\ \midrule
	\verb=\forall*=		& \multirow{2}{*}{\( \forall* \)} &\multirow{4}{*}{For almost all.} \\
	\tab \verb=\forallae=	&				  & \\[6pt]
	\verb=\forall*[x < y]=		& \( \forall*[x < y ] \) & \\[6pt]
	\verb=\forall*(x < y)=		& \( \forall*(x < y ) \) & \\ \midrule
	\verb=\True=				& \( \True \) & \\ \midrule
	\verb=\False=				& \( \False \) & \\ \midrule
	\verb=\Land \phi_i=				& \( \Land \phi_i \) & Operator form of and\\ \midrule
	\verb=\Lor \phi_i=				& \( \Lor \phi_i \) & Operator form of or\\ \midrule
	\verb=\LLand \phi_i=				& \( \LLand \phi_i \) & Infinitary conjunction\\ \midrule
	\verb=\LLor \phi_i=				& \( \LLor \phi_i \) & Infinitary disjunction\\ 
	\bottomrule
\end{tabular}
\subsection{Spaces}      
To disable these commands pass the option \verb=nospaces=.\\

\begin{tabular}{l |  l | l}\toprule  
	\verb=\bstrs=		       & \( \bstrs  \) & Finite binary strings        \\	\midrule
	\verb=\wstrs=                 & \( \wstrs  \) & Finite sequences of integers \\ 	\midrule
	\verb=\cantor=                & \( \cantor \) & Cantor space		     \\    \midrule
	\verb=\baire=                 & \( \baire  \) & Baire space                  \\[6pt] 
	\verb=\Baire=                 & \( \Baire  \) & Alternate baire space        \\ 
		\bottomrule
	\end{tabular}
	
\subsection{Strings}      
To disable these commands pass the option \verb=nostrings=.\\

\begin{tabular}{l |  l | l}\toprule  
	\verb=\str{1,0,1}=		     & \(   \str{1,0,1}           \) & \multirow{2}{*}{Strings/Codes for strings}  \\ 
	\tab \verb=\code{5,8,13}=                & \(   \code{5,8,13}         \) &   \\ \midrule
	\verb=\EmptyStr=                    & \(   \EmptyStr             \) &  \multirow{2}{*}{Empty string}  \\[6pt] 
	\tab \verb=\estr=                        & \(   \estr                 \) &   \\ \midrule
	\verb=\decode{\sigma}{3}=           & \(   \decode{\sigma}{3}    \) & Alternate notation for \( \sigma(3) \)   \\ \midrule
	\verb=\sigma\concat\tau=            & \(   \sigma\concat\tau     \) & \multirow{2}{*}{Concatenation}   \\[6pt]
	\verb=\sigma\concat[0]=             & \(   \sigma\concat[0]      \) &   \\ \midrule
	\verb=\strpred{\sigma}=             & \(   \strpred{\sigma}      \) & The immediate predecessor of \( \sigma \)  \\ \midrule
	\verb=\lh{\sigma}=                  & \(   \lh{\sigma}           \) & Length of \( \sigma \)  \\ \midrule
	\verb=\sigma \incompat \tau=        & \(   \sigma \incompat \tau  \) & \multirow{2}{*}{Incompatible strings}  \\
	\tab \verb=\sigma \incomp \tau=          & \(   \sigma \incomp \tau   \) &   \\ \midrule
	\verb=\sigma \compat \tau=          & \(   \sigma \compat \tau   \) &  Compatible strings \\ \midrule
	\verb=\pair{x}{y}=                  & \(   \pair{x}{y}           \) & Code for the pair \( (x,y) \)  \\ \midrule
	\verb=\setcol{X}{n}=                & \(   \setcol{X}{n}         \) & \( \set{y}{\pair{n}{y} \in X} \)  \\ \midrule
	\verb=\setcol{X}{\leq n}=           & \(   \setcol{X}{\leq n}    \) & \( \set{ \pair{x}{y}}{\pair{x}{y} \in X \land x \leq n} \)   \\ 
		\bottomrule
	\end{tabular}
	
\subsection{Trees}      
To disable these commands pass the option \verb=notrees=.\\

\begin{tabular}{l |  l | l}\toprule  	
	\verb=\CBderiv{T}=		      & \(  \CBderiv{T}		      \) & \multirow{2}{*}{Cantor-Bendixson Derivative} \\[6pt] 
	\verb=\CBderiv[\alpha]{T}=           & \(  \CBderiv[\alpha]{T}       \) & \\ \midrule
	\verb=\pruneTree{T}=                 & \(  \pruneTree{T}             \) & \( \set{\sigma \in T}{\exists(g)(g \in [T] \land \sigma \subset g)} \) \\ \midrule
	\verb=\hgt{T}=                       & \(  \hgt{T}                   \) & \\ 
		\bottomrule
	\end{tabular}
	
\subsection{Set Relations}      
To disable these commands pass the option \verb=nosetrels=.\\  Note that many of these commands are extensions of existing commands.

\begin{tabular}{l |  l | l}\toprule 
       \verb=X \subset* Y=    		& \( X \subset*    Y\)	& \multirow{2}{*}{All but finitely much of \( X \) is in \( Y \)} \\ 
   \verb=X \subseteq* Y=            & \( X \subseteq*  Y\)  & \\ \midrule
       \verb=X \supset* Y=              & \( X \supset*    Y\)  & \multirow{2}{*}{All but finitely much of \( Y \) is in \( X \)} \\ 
   \verb=X \supseteq* Y=            & \( X \supseteq*  Y\)  & \\ \midrule
       \verb=X \eq Y=                   & \( X \eq         Y\)  &  Macro for \verb~=~ \\ \midrule
       \verb=X \eq* Y=                  & \multirow{2}{*}{\( X \eq*        Y\)}  & \multirow{2}{*}{Equal mod finite} \\ 
  \tab \verb=X \eqae Y=                 & & \\ \midrule
       \verb=X \infsubset Y=            & \( X \infsubset  Y\)  & \( X \subset Y \land \card{Y \setminus X}=\omega \) \\ \midrule
       \verb=X \infsubset* Y=           & \( X \infsubset* Y\)  &  \( X \subset* Y \land \card{Y \setminus X}=\omega \) \\ \midrule
       \verb=X \infsupset Y=            & \( X \infsupset  Y\)  &  \( Y \subset X \land \card{X \setminus Y}=\omega \) \\ \midrule
       \verb=X \infsupset* Y=           & \( X \infsupset* Y\)  & \( Y \subset* X \land \card{X \setminus Y}=\omega \) \\ \midrule
       \verb=X \majsubset Y=            & \( X \majsubset  Y\)  & \( X \) is a major subset of \( Y \) \\ \midrule
       \verb=X \majsupset Y=            & \( X \majsupset  Y\)  & \( Y \) is a major subset of \( X \) \\ 
		\bottomrule
	\end{tabular}

\subsection{Ordinal Notations}      
To disable these commands pass the option \verb=noordinalnotations=.\\

\begin{tabular}{l |  l | l}\toprule 
	\verb=\wck=			        & \( 	\wck                      \)			       & First non-computable ordinal \\ \midrule 
	\verb=\ordzero=                        & \( 	\ordzero                   \)                          & Notation for ordinal \( 0 \)\\ \midrule
	\verb=\abs{\alpha}=			& \( \abs{\alpha} \)						& Ordinal \( \alpha \) denotes \\ \midrule
	\verb=\kleeneO=                        & \multirow{2}{*}{\( 	\kleeneO                   \)}         & \multirow{2}{*}{Set of ordinal notations} \\[6pt]
\tab	\verb=\ordNotations=                   &                                                              &  \\[6pt]
	\verb=\kleeneO*=                       & \multirow{3}{*}{\( 	\kleeneO*                  \)}         & \multirow{3}{*}{Unique set of ordinal notations} \\[6pt]
\tab	\verb=\uniqOrdNotations=               &                                                              & \\[6pt]
\tab	\verb=\kleeneOuniq=                    &                                                              & \\[6pt]
	\verb=\kleeneO(X)=                     & \( 	\kleeneO(X)                \)                          & Relativized ordinal notations \\[6pt]
	\verb=\kleeneO[\alpha]=                & \( 	\kleeneO[\alpha]           \)                          & Ordinal notations for ordinals \( < \abs{\alpha} \) \\[6pt]
	\verb=\kleeneO*(X)[\alpha]=            & \( 	\kleeneO*(X)[\alpha]       \)                          & \\ \midrule
	\verb=\alpha \kleeneless \beta=        & \( 	\alpha \kleeneless \beta   \)                          & Ordering on notations \\  \midrule
	\verb=\alpha \kleenel    \beta=        & \( 	\alpha \kleenel    \beta   \)                          & \\ \midrule
	\verb=\alpha \kleeneleq  \beta=        & \( 	\alpha \kleeneleq  \beta   \)                          & \\ \midrule
	\verb=\alpha \kleenegtr  \beta=        & \( 	\alpha \kleenegtr  \beta   \)                          & \\ \midrule
	\verb=\alpha \kleenegeq  \beta=        & \( 	\alpha \kleenegeq  \beta   \)                          & \\ \midrule
	\verb=\alpha \kleenePlus \beta=        & \( 	\alpha \kleenePlus \beta   \)                          & Effective addition of notations \\ \midrule
	\verb=\alpha \kleeneMul  \beta=        & \( 	\alpha \kleeneMul  \beta   \)                          & Effective multiplication of notations \\  \midrule
	\verb=\kleenelim{\lambda}{n}=          & \( 	\kleenelim{\lambda}{n}     \)                          & The \( n \)-th element in effective limit defining notation \( \lambda \)\\  \midrule
        \verb=\kleenepred{\alpha}=             & \(  \kleenepred{\alpha}          \)                          & Predecessor of \( \alpha \) if defined \\ \midrule
	\verb=\kleenehgt{R}=                   & \multirow{2}{*}{\( 	\kleenehgt{R}              \)}        & Heigh of computable relation \( R \) \\ 
\tab	\verb=\hgtO{R}=                        & & \\ 
		\bottomrule
	\end{tabular}
	
\subsection{Forcing}      
To disable these commands pass the option \verb=noforcing=.\\ 

\begin{tabular}{l |  l | l}\toprule 
	\verb=\sigma \forces \phi=	        	& \multirow{2}{*}{\(  \sigma \forces \phi         \)}	& \multirow{2}{*}{\( \sigma \) forces \( \phi \)}\\ 
	\tab \verb=\sigma \frc \phi=                        &    & \\ 
	\verb=\sigma \forces(X) \phi=               & \(  \sigma \forces(X)[T] \phi    \)   & \( \phi \) is formula relative to \( X \) \\ 
	\verb=\sigma \forces[T] \phi=               & \(  \sigma \forces(X)[T] \phi    \)   & Local forcing on \( T \)\\
	\verb=\sigma \forces* \phi=                    & \(  \sigma \forces* \phi        \)    & Strong forcing \\ 
	\bottomrule
\end{tabular}  

\subsection{Syntax}      
To disable these commands pass the option \verb=nosyntax=.\\  All syntax classes can be relativized with an optional argument in square brackets even when not listed below.  Only the \( \Delta \) formula classes are listed below since the syntax is identical for \( \Sigma \) and \( \Pi \).  Capitalizing the first letter gives the boldface version in all cases (except the computable infinitary formulas as this doesn't make sense).  Not all formulas/abbreviations are demonstrated below given the huge number but the enough are included to make it clear what command is required to generate the desired formula class, e.g., substituting pi for delta does what you think it does.

To change the syntax for the computable infinitary formulas you can pass the options \verb=cdeltasym=, \verb=csigmasym= and \verb=cpisym= set equal to the command to produce your desired symbol.  This is UNTESTED and quite likely doesn't work yet.  If you desire this feature and it doesn't work send me a bug report. 

\begin{xtabular}{l |  l | l}\toprule 
	\verb=\Cdeltan[X]{\alpha}=          & \( \Cdeltan[X]{2}    \)      & The computable \( \delta^{X}_\alpha \) formulas  \\ \midrule
	\verb=\deltan{2}=              & \( \deltan{2}        \)      & \\ \midrule
	\verb=\deltan[X]{2}=           & \( \deltan[X]{2}     \)      & \\ \midrule
	\verb=\deltaZeroN[X]{2}=       & \multirow{2}{*}{\( \deltaZeroN[X]{2} \)}      & \\
	\tab \verb=\deltazn[X]{2}=          &                              & \\ \midrule
	\verb=\deltaZeroOne[X]=        & \multirow{2}{*}{\( \deltaZeroOne[X]  \)}      & \\ 
	\tab \verb=\deltazi[X]=             &                              & \\ \midrule         
	\verb=\sigmaZeroTwo[X]=        & \multirow{2}{*}{\( \deltaZeroTwo[X]  \)}      & \\ 
	\tab \verb=\sigmazii[X]=            &                              & \\ \midrule         
	\verb=\deltaZeroThree[X]=      & \multirow{2}{*}{\( \deltaZeroThree[X]\)}      & \\ 
	\tab \verb=\deltaziii[X]=           &                              & \\ \midrule         
	\verb=\deltaOneN[X]{2}=        & \multirow{2}{*}{\( \deltaOneN[X]{2}  \)}      & \\ 
	\tab \verb=\deltaIn[X]{2}=          &                              & \\ \midrule         
	\verb=\deltaOneOne[X]=         & \multirow{2}{*}{\( \deltaOneOne[X]   \)}      & \\ 
	\tab \verb=\deltaIi[X]=             &                              & \\ \midrule         
	\verb=\deltaOneTwo[X]=         & \multirow{2}{*}{\( \deltaOneTwo[X]   \)}      & \\ 
	\tab \verb=\deltaIii[X]=            &                              & \\ \midrule         
	\verb=\deltaOneThree[X]=       & \multirow{2}{*}{\( \deltaOneThree[X] \)}      & \\ 
	\tab \verb=\deltaIiii[X]=           &                              & \\ \midrule  
	\verb=\pizi=              & \( \pizi      \)      & \\ \midrule      
	\verb=\pizn[X]{n}=              & \( \pizn[X]{n}      \)      & \\ \midrule
	\verb=\Deltan{2}=              & \( \Deltan{2}        \)      & \\ \midrule  
	\verb=\DeltaOneN[X]{n}=         & \( \DeltaOneN[X]{n} \)  & \\ \midrule
 
	\verb=\logic{\omega_1}{\omega}= & \( \logic{\omega_1}{\omega} \) & Indicates the kind of infinitary logic\\ 
		\bottomrule
\end{xtabular}
                    
\subsection{MRref}

Finally to enable the mrref helper macros pass the option \verb=mrref=.\\  These macros normalize the formating of mathscinet references for supported bibliography styles and ensure the MR numbers link to the mathscinet page of the article.  Unless you have a good reason (like journal formatting guidelines) there is no reason not to always pass this option.  Note this option requires the hyperref package.                    
	                              
	
\section{Release Notes}

\begin{itemize}  
	\item[1.3] 06/20/2012 - Added abbreviations for computable infinitary formulas and made a few minor fixes.
	\item[1.2] 01/01/2011 - Fixed awful option processing bug preventing most options from being recognized and added mrref option.
	\item[1.0] 10/15/2010 - Initial public release
\end{itemize}
	
	
	
	
	
	
	
	
	
	                                     

\end{document}